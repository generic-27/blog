<!DOCTYPE html>
<html lang="en" style="background-color: #0e1111">
	<head>
		<title>Generic blog</title>
		<meta charset="utf-8" />
		<link rel="icon" href="../favicon.png" />
		<meta name="viewport" content="width=device-width" />
		
		<link href="../_app/immutable/assets/4.4ef0ed4e.css" rel="stylesheet">
		<link href="../_app/immutable/assets/article-main-header.55319824.css" rel="stylesheet">
		<link rel="modulepreload" href="../_app/immutable/entry/start.bd3a145b.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/scheduler.e108d1fd.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/singletons.b4832734.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/control.f5b05b5f.js">
		<link rel="modulepreload" href="../_app/immutable/entry/app.d00c1d83.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.2b92d2ca.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/0.934ac79d.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/4.36bd7b44.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/article-main-header.9d852d06.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/navigation.2d03f78e.js">
	</head>
	<body style="margin: 0">
		<div style="display: contents">  <div class="blog-container"><div class="objects_container svelte-17riu38"><div class="blog-article-main-header sticky svelte-k07hpd"><button class="home-button svelte-k07hpd" data-svelte-h="svelte-ox9wwz">Home</button> </div> <div class="blog-text-container"><h1 data-svelte-h="svelte-1os1ssi">Objects</h1> <div class="blog-paragraph" data-svelte-h="svelte-6f8u7p">Everything in JavaScript is an <code>object</code> - A misconception I have been living with.
			<code>objects</code> are the building blocks in JavaScript but they are one of the 6 primary
			types.
			<div><code>string</code>, <code>number</code>, <code>boolean</code>,
				<code>null</code>,
				<code>undefined</code>, <code>object</code></div></div> <div class="blog-paragraph" data-svelte-h="svelte-kfolhs">Everything in JavaScript is not an <code>object</code> but there are some some object
			sub-types, which are also referred to as complex primitives. <code>function</code> for example
			is a callable object, and they are referred to as the &quot;first class&quot;. <code>Arrays</code> are
			also <code>objects</code> with extra behavior and data is organization is more structured. So,
			what is the difference between a primitive <code>string</code> and an <code>object</code> <code>String</code></div> <div class="blog-sub-header" data-svelte-h="svelte-1ne7xc4">Built-in objects</div> <div class="blog-paragraph" data-svelte-h="svelte-1kd7iyb">There are multiple <code>object</code> sub-types which are referred to as built-in objects.
			<div><code>String</code>, <code>Number</code>, <code>Boolean</code>,
				<code>Object</code>, <code>Function</code>, <code>Array</code>,
				<code>Date</code>, <code>RegExp</code>, <code>Error</code></div>
			Each of these
			<code>objects</code> can be used as a contructor. Upon invocation it creates a new
			<code>object</code> of the specified type.</div> <div class="blog-code-block"><!-- HTML_TAG_START --><pre><code>    var strPrimitive = &quot;I am a string&quot;;
    typeof strPrimitive;							// &quot;string&quot;
    strPrimitive instanceof String;					// false

    var strObject = new String( &quot;I am a string&quot; );
    typeof strObject; 								// &quot;object&quot;
    strObject instanceof String;					// true

    // inspect the object sub-type
    Object.prototype.toString.call( strObject );
</code></pre>
<!-- HTML_TAG_END --></div> <div class="blog-paragraph" data-svelte-h="svelte-16nuv56">The example above clearly demarcates the difference between a primitive and an
			<code>object</code> type. The primitive variable is not an instance of the <code>String</code> <code>object</code> type but is just a primitive literal. But, in order to perform any
			operations on the the primitive variable it needs to be wrapped in the <code>object</code> type.
			JavaScript handles coercing the value and we do not have to handle that manually.</div> <div class="blog-sub-header" data-svelte-h="svelte-16wez9v">Contents of an object</div> <div class="blog-paragraph" data-svelte-h="svelte-y4relm">The contents of an <code>object</code> consist of values (which can be any type) stored at
			specific named locations which are called properties. When we declare an <code>object</code> the
			properties are not literally stored in the container. The property names are stored in the container
			and those act as references to the where the value is stored.</div> <div class="blog-paragraph" data-svelte-h="svelte-1ic1k41">There are two ways in which one can access <code>object</code> properties.
			<ol class="blog-list-elements"><li><code>.</code> operator</li> <li><code>[ ]</code> operator</li></ol>
			The
			<code>.</code> operator requires the properties to meet the <code>identifier</code> naming
			standards, whereas the <code>[ ]</code> operator can take any <b>UTF-8/unicode</b> compatible string.</div> <div class="blog-sub-header" data-svelte-h="svelte-uy212c">Duplicating objects</div> <div class="blog-paragraph" data-svelte-h="svelte-5fived">Duplicating <code>objects</code> in JavaScript can be tricky. In general there are two modes
			of copying <code>objects</code> <ol class="blog-list-elements"><li>Shallow copy</li> <li>Deep copy</li></ol>
			Shallow copy creates a new<code>object</code> with the same references and values that the
			original <code>object</code> had. Deep copy on the other hand create new references where
			modifying the newly created <code>object</code> does not modify the original
			<code>object</code>.</div> <div class="blog-paragraph" data-svelte-h="svelte-8wh7q">Not everything can be deep copied in JavaScript. Let&#39;s look at an example.</div> <div class="blog-code-block"><!-- HTML_TAG_START --><pre><code>    function anotherFunction() { /*..*/ }

    var anotherObject = {
        c: true
    };

    var anotherArray = [];

    var myObject = {
        a: 2,
        b: anotherObject,	// reference, not a copy!
        c: anotherArray,	// another reference!
        d: anotherFunction
    };

    anotherArray.push( anotherObject, myObject );
</code></pre>
<!-- HTML_TAG_END --></div> <div class="blog-paragraph" data-svelte-h="svelte-5gt4vt">The above example creates a circular dependency. <code>myObject</code> has a reference of
			<code>anotherArray</code> and <code>anotherArray</code> has a reference of
			<code>myObject</code>. When trying to make a deep copy of <code>myObj</code> there are some
			considerations. Do we stop as soon as we find the cylical dependency? How do we deep copy a
			function ? These issues make deep copying difficult and for certain <code>objects</code> deep
			copying does not exist. But, there are certain <code>objects</code> that can be deep copied
			and to know which <code>object</code> , we could do something like this.</div> <div class="blog-code-block"><!-- HTML_TAG_START --><pre><code>    var newObj = JSON.parse( JSON.stringify( someObj ) );
</code></pre>
<!-- HTML_TAG_END --></div> <div class="blog-paragraph" data-svelte-h="svelte-1lkjbvc">When an<code>object</code> is JSON-safe(can be serialized to a JSON string and then re-parsed
			to an <code>object</code> with same structure) it can be deep copied.</div></div> </div></div> 
			
			<script>
				{
					__sveltekit_1yej8gu = {
						assets: "/blog",
						base: new URL("..", location).pathname.slice(0, -1),
						env: {}
					};

					const element = document.currentScript.parentElement;

					const data = [null,{"type":"data","data":null,"uses":{}}];

					Promise.all([
						import("../_app/immutable/entry/start.bd3a145b.js"),
						import("../_app/immutable/entry/app.d00c1d83.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 4],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
